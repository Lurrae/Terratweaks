A highly-configurable collection of vanilla changes! Most of these changes are quite minor, but there are some additional features which significantly alter the balance of vanilla Terraria. Most of these more potent changes are disabled by default. Terratweaks also has numerous mod calls, which are listed below.
This mod currently implements too many changes to list directly, but here's a brief summary of some options you can expect to see in Terratweaks:
- Options to disable certain vanilla mechanics, namely Expert mode changes like enemy stat scaling in Hardmode/post-Plantera, and Lava Slimes dropping lava on death
- Options to show more precise stats in item tooltips
- Options to give a few vanilla armor sets more unique set bonuses, or to buff them or rework them entirely
- Options to buff Expert-exclusive accessories after defeating certain bosses, as well as options to buff or rework other items in general
- Options to add certain items to town NPCs' shops, make the size of an NPC's house affect their happiness, make the Goblin Tinkerer give you better reforges if he's happier, and more
- Options to add crafting or Shimmer transmutation recipes for a TON of vanilla items with no recipe
- Various joke options that range from making paper airplanes give enemies paper cuts to making all pots and trees in For the Worthy worlds drop bombs
Terratweaks also has three sub-categories for cross-mod adjustments: Calamitweaks for Calamity edits, Thoritweaks for Thorium edits, and Alchemitweaks for Alchemist NPC Lite edits
Calamitweaks has a lot of options, such as reverting some of Calamity's vanilla changes, buffing some Calamity accessories, and even adding Calamity swords to the Zenith recipe and adding Calamity stations to Magic Storage's combined stations!
Thoritweaks and Alchemitweaks have comparatively fewer options, but if you want to, for example, make the Cook's food edible in combat or disable the existence of AlchLite's custom potions, there's config options to allow things like that! Thoritweaks also has options that mirror Calamitweaks' Zenith and Magic Storage recipe tweak options.
For a full list of what Terratweaks has to offer, you'll have to look at the config options in-game, or look through the code on Github (you can also check the changelogs here on Steam to get an idea of what options exist)

[h3][u]MOD CALLS:[/u][/h3]
[list]
[*][code]Call("Query", string settingToQuery)[/code] Returns the state of the config option being queried, though will throw an exception if a string is not provided or the string does not match any config name. Currently supports every config option in the mod, and accepts quite a few different aliases (and is even case-insensitive!). Useful for implementing custom behavior with certain config options active! Note that any config option with multiple settings (such as No Damage Variance) will return a number between 0 and X, with 0 being vanilla behavior and X being whatever the most different from vanilla config option is. Most options range from 0-2, but Sturdier Larvae ranges from 0-3.
[*][code]Call("AddPermConsumable", int itemID, Func<Player, bool> condition)[/code] Registers a new permanent consumable item (or updates the conditions for one that's already handled) for use with the relevant client-side config. The condition should look something like this: (Player p) => p.usedAegisCrystal; where p.usedAegisCrystal is a variable denoting whether the item has been consumed or not. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddPermConsumable", int itemID, Func<Player, Vector2> condition)[/code] A variant of "AddPermConsumable" for multi-use consumables like Life Crystals. The condition should look something like this: (Player p) => new Vector2(p.consumedLifeCrystals, 15); where p.consumedLifeCrystals is a variable denoting how many of the item has been consumed, and 15 is the maximum number of items that can be consumed. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddDefensiveEnemy", "DamageResistant", int npcID, float dmgResist, float kbResist, Func<NPC, bool> defensiveState)[/code] Registers a new defensive enemy (similar to the Granite Golem or Granite Elemental). The defensiveState should look something like this: (NPC npc) => npc.ai[2] < 0f; Note that all enemies that use the Granite Elemental's AI are automatically added, but this call can be used to edit their DR and KB resist during their defensive states if you so choose (these default to 25% damage taken and -5% knockback resistance, respectively), or provide a different check for their defensive state (the default AI checks if npc.ai[0] == -1). Returns true if successful, but throws an exception if an invalid argument is provided. More types of defensive enemies beyond "DamageResistant" may be added in the future.
[*][code]Call("RemoveDefensiveEnemy", "DamageResistant", int npcID)[/code] Removes a defensive enemy from the list. This allows you to stop enemies with Granite Elemental AI from having changes automatically applied, in case you want to handle them manually.
[*][code]Call("AddNoContactDamageEnemy", int npcID)[/code] Registers an enemy which does not deal contact damage if the "Ranged Enemies Deal No Contact Damage" config option is enabled. By default, all enemies that use Caster AI are marked as "ranged enemies", as well as several vanilla enemies like Hornets and their variants, enemies that use bows or guns, and some miscellaneous enemies like Angry Nimbus and Icy Merman. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveNoContactDamageEnemy", int npcID)[/code] Stops the listed enemy from having its contact damage removed/disabled. Could be useful if you want to override certain vanilla enemies being counted as "ranged attackers" (such as Probes on Infernum Mode). Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddIgnoredSummonWeapon", int itemID)[/code] Registers a summon weapon which should continue to cost mana and should not apply the 3-second cooldown if used while a boss is alive. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveIgnoredSummonWeapon", int itemID)[/code] Removes a summon weapon from the list in the above call. Because there are no weapons in the list by default, this is only useful if you need to conditionally add a weapon. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddHotDebuff", int buffID)[/code] Registers a debuff which should be considered a 'hot' debuff, used by the Lucy the Axe rework. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveHotDebuff", int buffID)[/code] Removes a hot debuff from the list in the above call. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddColdDebuff", int buffID)[/code] Registers a debuff which should be considered a 'cold' debuff, used by the Lucy the Axe rework. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveColdDebuff", int buffID)[/code] Removes a cold debuff from the list in the above call. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddShimmerableBossDrop", string listToEdit, int itemID)[/code] Adds an item to the specified list, creating a new list if none are found. The lists for vanilla bosses mostly use the boss' name, though armor/vanity sets use the set name instead. Returns true if successful, but throws an exception if an invalid argument is provided. Unlike most mod calls, this one MUST be called from OnModLoad() rather than PostSetupContent()! This is due to how Shimmer recipes are generated.
[*][code]Call("RemoveShimmerableBossDrop", string listToEdit, int itemID)[/code] Removes an item from the specified list. Lists with no items are ignored by Shimmer recipe generation. Returns true if successful, but throws an exception if an invalid argument is provided. Unlike most mod calls, this one MUST be called from OnModLoad() rather than PostSetupContent()! This is due to how Shimmer recipes are generated.
[*][code]Call("AddHappinessFactorBlacklistedNPC", int npcID)[/code] Registers an NPC that should not gain/lose happiness based on the size of their house, similarly to the Princess. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddHappinessFactorLocalization", int npcID, string localizationKey)[/code] Registers a localization key for the given NPC, used by the config option to make house size affect happiness. An example localization key is: "Mods.Terratweaks.HappinessFactors.Guide". The localization key MUST contain the following four keys: "TinySpace", "SmallSpace", "BigSpace", and "HugeSpace". See Terratweaks' localization files for examples. If this is not specified for a given NPC, that NPC will use placeholder text. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddSellableWeapon", int itemID, int npcID, List<Condition> conditions)[/code] Adds the specified item to the specified NPC's shop if the NPC is happy enough. If a list of conditions are provided, those conditions must also be met (for example, you can provide a list containing Condition.Hardmode to ensure that the NPC only sells their weapon in Hardmode). Returns true if successful, but throws an exception if an invalid argument is provided. If something other than a list of conditions is provided as the third argument (not counting the initial string), it will be ignored but won't throw an exception.
[/list]