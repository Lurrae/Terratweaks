A highly-configurable collection of vanilla changes brought to you by the developers of Terrarmory! Most of these changes are quite minor, but there are some additional features which significantly alter the balance of vanilla Terraria. These are disabled by default. Terratweaks also has numerous mod calls, which are listed below.
This mod currently implements too many changes to list in the mod description, so you'll have to browse the mod's config to see them all.

[h3][u]MOD CALLS:[/u][/h3]
[list]
[*][code]Call("Query", string settingToQuery)[/code] Returns the state of the config option being queried, though will throw an exception if a string is not provided or the string does not match any config name. Currently supports every config option in the mod, with aliases for some of them. Useful for implementing custom behavior with certain config options active! Note that any config option with three settings (such as No Damage Variance) will return a number between 0 and 2, with 0 being vanilla behavior, 1 being the more limited option, and 2 being the full option.
[*][code]Call("AddPermConsumable", int itemID, Func<Player, bool> condition)[/code] Registers a new permanent consumable item (or updates the conditions for one that's already handled) for use with the relevant client-side config. The condition should look something like this: (Player p) => p.usedAegisCrystal; where p.usedAegisCrystal is a variable denoting whether the item has been consumed or not. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddPermConsumable", int itemID, Func<Player, Vector2> condition)[/code] A variant of "AddPermConsumable" for multi-use consumables like Life Crystals. The condition should look something like this: (Player p) => new Vector2(p.consumedLifeCrystals, 15); where p.consumedLifeCrystals is a variable denoting how many of the item has been consumed, and 15 is the maximum number of items that can be consumed. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddDefensiveEnemy", "DamageResistant", int npcID, float dmgResist, float kbResist, Func<NPC, bool> defensiveState)[/code] Registers a new defensive enemy (similar to the Granite Golem or Granite Elemental). The defensiveState should look something like this: (NPC npc) => npc.ai[2] < 0f; Note that all enemies that use the Granite Elemental's AI are automatically added, but this call can be used to edit their DR and KB resist during their defensive states if you so choose (these default to 25% damage taken and -5% knockback resistance, respectively), or provide a different check for their defensive state (the default AI checks if npc.ai[0] == -1). Returns true if successful, but throws an exception if an invalid argument is provided. More types of defensive enemies beyond "DamageResistant" may be added in the future.
[*][code]Call("RemoveDefensiveEnemy", "DamageResistant", int npcID)[/code] Removes a defensive enemy from the list. This allows you to stop enemies with Granite Elemental AI from having changes automatically applied, in case you want to handle them manually.
[*][code]Call("AddNoContactDamageEnemy", int npcID)[/code] Registers an enemy which does not deal contact damage if the "Ranged Enemies Deal No Contact Damage" config option is enabled. By default, all enemies that use Caster AI are marked as "ranged enemies", as well as several vanilla enemies like Hornets and their variants, enemies that use bows or guns, and some miscellaneous enemies like Angry Nimbus and Icy Merman. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveNoContactDamageEnemy", int npcID)[/code] Stops the listed enemy from having its contact damage removed/disabled. Could be useful if you want to override certain vanilla enemies being counted as "ranged attackers" (such as Probes on Infernum Mode). Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddIgnoredSummonWeapon", int itemID)[/code] Registers a summon weapon which should continue to cost mana and should not apply the 3-second cooldown if used while a boss is alive. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveIgnoredSummonWeapon", int itemID)[/code] Removes a summon weapon from the list in the above call. Because there are no weapons in the list by default, this is only useful if you need to conditionally add a weapon. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddHotDebuff", int buffID)[/code] Registers a debuff which should be considered a 'hot' debuff, used by the Lucy the Axe rework. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveHotDebuff", int buffID)[/code] Removes a hot debuff from the list in the above call. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddColdDebuff", int buffID)[/code] Registers a debuff which should be considered a 'cold' debuff, used by the Lucy the Axe rework. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("RemoveColdDebuff", int buffID)[/code] Removes a cold debuff from the list in the above call. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddShimmerableBossDrop", string listToEdit, int itemID)[/code] Adds an item to the specified list, creating a new list if none are found. The lists for vanilla bosses mostly use the boss' name, though armor/vanity sets use the set name instead. Returns true if successful, but throws an exception if an invalid argument is provided. Unlike most mod calls, this one MUST be called from OnModLoad() rather than PostSetupContent()! This is due to how Shimmer recipes are generated.
[*][code]Call("RemoveShimmerableBossDrop", string listToEdit, int itemID)[/code] Removes an item from the specified list. Lists with no items are ignored by Shimmer recipe generation. Returns true if successful, but throws an exception if an invalid argument is provided. Unlike most mod calls, this one MUST be called from OnModLoad() rather than PostSetupContent()! This is due to how Shimmer recipes are generated.
[*][code]Call("AddHappinessFactorBlacklistedNPC", int npcID)[/code] Registers an NPC that should not gain/lose happiness based on the size of their house, similarly to the Princess. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddHappinessFactorLocalization", int npcID, string localizationKey)[/code] Registers a localization key for the given NPC, used by the config option to make house size affect happiness. An example localization key is: "Mods.Terratweaks.HappinessFactors.Guide". The localization key MUST contain the following four keys: "TinySpace", "SmallSpace", "BigSpace", and "HugeSpace". See Terratweaks' localization files for examples. If this is not specified for a given NPC, that NPC will use placeholder text. Returns true if successful, but throws an exception if an invalid argument is provided.
[*][code]Call("AddSellableWeapon", int itemID, int npcID, List<Condition> conditions)[/code] Adds the specified item to the specified NPC's shop if the NPC is happy enough. If a list of conditions are provided, those conditions must also be met (for example, you can provide a list containing Condition.Hardmode to ensure that the NPC only sells their weapon in Hardmode). Returns true if successful, but throws an exception if an invalid argument is provided.
[/list]